#version 330 core

const int MAX_LIGHTS=8;

struct Light{
    vec4 position_cameraspace;
    vec4 direction_cameraspace;
    vec4 color;
    int type;
    float power;
    float kC;
    float kL;
    float kQ;
    float cosCutoff;
    float cosInner;
    float exponent;
};

// Pass in things as vec4, because vec3 are intepreted size of vec4 (16 bytes), hence, to prevent offset confusion, just pass in as vec4
layout(std140)uniform Material{
    vec4 kColour;
    
    vec4 kAmbient;
    vec4 kDiffuse;
    vec4 kSpecular;
    float kShininess;
}material;

layout(std140)uniform LightBlock{
    Light lights[MAX_LIGHTS];
}lightBlock;

// Interpolated values from the vertex shaders
in VERTEX_DATA{
    vec3 fragmentPosition;
    vec2 texCoord;
    mat3 TBN;
}vertexDataIn;

// Output data
out vec4 frag_color;

uniform int numLights;
// uniform Light lights[MAX_LIGHTS];
uniform bool lightEnabled;
// uniform vec3 viewDir;

uniform sampler2D u_normalMap;

uniform bool u_textureEnabled;
uniform sampler2D u_tex;

uniform bool u_textEnabled;
uniform vec3 u_textColour;

void main()
{
    vec3 normal= texture(u_normalMap, vertexDataIn.texCoord).rgb;
    normal = normalize(normal * 2.0 - 1.0);
    vec3 color;
    
    if (u_textEnabled == false)
    {
        color = material.kAmbient.rgb * ((u_textureEnabled || u_textEnabled) ? texture(u_tex, vertexDataIn.texCoord).rgb : material.kColour.rgb);
        if(lightEnabled)
        {
            for(int i=0;i<numLights;++i)
            {
                Light light=lightBlock.lights[i];
                vec3 lightDir;
                float attenuation;
                if(light.type==0)// Point light
                {
                    lightDir= vertexDataIn.TBN * normalize(vec3(light.position_cameraspace)-vertexDataIn.fragmentPosition);
                    float dist=length(vec3(light.position_cameraspace)-vertexDataIn.fragmentPosition);
                    attenuation=1./(light.kC+light.kL*dist+light.kQ*dist*dist);
                }
                else if(light.type==1)// Directional light
                {
                    lightDir= vertexDataIn.TBN * -normalize(vec3(light.direction_cameraspace));
                    attenuation=1.;
                }
                else// Spot light
                {
                    lightDir= vertexDataIn.TBN * normalize(vec3(light.position_cameraspace)-vertexDataIn.fragmentPosition);
                    float dist=length(vec3(light.position_cameraspace)-vertexDataIn.fragmentPosition);
                    float spot=dot(lightDir,normalize(vec3(-light.direction_cameraspace)));
                    attenuation=spot>light.cosCutoff?1./(light.kC+light.kL*dist+light.kQ*dist*dist):0.;
                }
                
                float diff=max(dot(normal,lightDir),0.);
                vec3 reflectDir=reflect(-lightDir,normal);
                
                float spec=pow(max(dot(normalize(-vertexDataIn.fragmentPosition),reflectDir),0.),material.kShininess);
                color+=(material.kDiffuse.rgb*diff+material.kSpecular.rgb*spec)*light.color.rgb*attenuation;
            }
        }
        frag_color=vec4(color,(u_textureEnabled || u_textEnabled ? texture(u_tex, vertexDataIn.texCoord).a : material.kColour.a));
    }
    else
    {
        frag_color = texture(u_tex, vertexDataIn.texCoord) * vec4(u_textColour, 1);
    }
}
