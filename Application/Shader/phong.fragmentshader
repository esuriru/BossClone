#version 330 core

const int MAX_LIGHTS=8;

struct Light{
	vec4 position_cameraspace;
	vec4 spotDirection;
	vec4 color;
	int type;
	float power;
	float kC;
	float kL;
	float kQ;
	float cosCutoff;
	float cosInner;
	float exponent;
};

// Pass in things as vec4, because vec3 are intepreted size of vec4 (16 bytes), hence, to prevent offset confusion, just pass in as vec4
layout(std140)uniform Material{
	vec4 kColour;
	
	vec4 kAmbient;
	vec4 kDiffuse;
	vec4 kSpecular;
	float kShininess;
}material;

layout(std140)uniform LightBlock{
	Light lights[MAX_LIGHTS];
}lightBlock;

// Interpolated values from the vertex shaders
in VERTEX_DATA{
	vec3 fragmentPosition;
	vec3 norm;
}vertexDataIn;

// Output data
out vec4 frag_color;

uniform int numLights;
// uniform Light lights[MAX_LIGHTS];
uniform bool lightEnabled;
// uniform vec3 viewDir;

void main()
{
	vec3 color=vec3(0,0,0);
	vec3 normal=normalize(vertexDataIn.norm);
	
	// cast back all our info from UBO
	vec3 m_colour=vec3(material.kColour);
	vec3 m_ambient=vec3(material.kAmbient);
	vec3 m_diffuse=vec3(material.kDiffuse);
	vec3 m_specular=vec3(material.kSpecular);
	float m_shininess=material.kShininess;
	
	vec3 l_lightPosition,l_colour,l_dir;
	float l_constant,l_linear,l_quad,l_outer,l_inner;
	if(lightEnabled)
	{
		for(int i=0;i<numLights;i++)
		{
			// cast back all our info from UBO
			l_colour=vec3(lightBlock.lights[i].color);
			switch(lightBlock.lights[i].type)
			{
				case 0:// point
				{
					// cast back all our info from UBO
					l_dir=vec3(lightBlock.lights[i].spotDirection);
					l_lightPosition=vec3(lightBlock.lights[i].position_cameraspace);
					l_constant=lightBlock.lights[i].kC;
					l_linear=lightBlock.lights[i].kL;
					l_quad=lightBlock.lights[i].kQ;
					
					vec3 viewDir=normalize(-vertexDataIn.fragmentPosition);
					vec3 lightDir=normalize(l_lightPosition-vertexDataIn.fragmentPosition);
					// diffuse shading
					float diff=max(dot(normal,lightDir),0.);
					// specular shading
					if(diff>0.)
					{
						vec3 reflectDir=reflect(lightDir,normal);
						float spec=pow(max(dot(viewDir,reflectDir),0.),m_shininess);
						// attenuation
						float distance=length(l_lightPosition-vertexDataIn.fragmentPosition);
						float attenuation=1./(l_constant+l_linear*distance+
							l_quad*(distance*distance));
							// combine results
							vec3 diffuse=l_colour*diff*m_diffuse;
							vec3 specular=l_colour*spec*m_specular;
							diffuse*=attenuation;
							specular*=attenuation;
							// color+=(diffuse+specular)*m_colour;
							color += (specular) + diffuse * m_colour;
						}
						break;
					}
					case 1://directional
					{
						l_dir=-vec3(lightBlock.lights[i].spotDirection);
						
						vec3 lightDir=normalize(l_dir);
						// diffuse shading
						float diff=max(dot(normal,lightDir),0.);
						// specular shading
						if(diff>0.)
						{
							vec3 reflectDir=reflect(-lightDir,normal);
							float spec=pow(max(dot(lightDir,reflectDir),0.),m_shininess);
							// combine results
							vec3 diffuse=l_colour*diff*m_diffuse;
							vec3 specular=l_colour*spec*m_specular;
							color+=(diffuse+specular)*m_colour;
						}
						break;
					}
					case 2://spot
					{
						l_dir=vec3(lightBlock.lights[i].spotDirection);
						l_lightPosition=vec3(lightBlock.lights[i].position_cameraspace);
						l_constant=lightBlock.lights[i].kC;
						l_linear=lightBlock.lights[i].kL;
						l_quad=lightBlock.lights[i].kQ;
						l_outer=lightBlock.lights[i].cosCutoff;
						l_inner=lightBlock.lights[i].cosInner;
						
						vec3 viewDir=normalize(vertexDataIn.fragmentPosition-l_lightPosition);
						vec3 lightDir=normalize(l_lightPosition-vertexDataIn.fragmentPosition);
						
						// diffuse shading
						float diff=max(dot(normal,lightDir),0.);
						// specular shading
						if(diff>0.)
						{
							vec3 reflectDir=reflect(lightDir,normal);
							float spec=pow(max(dot(viewDir,reflectDir),0.),m_shininess);
							// attenuation
							float distance=length(l_lightPosition-vertexDataIn.fragmentPosition);
							float attenuation=1./(l_constant+l_linear*distance+
								l_quad*(distance*distance));
								// spotlight intensity
								float theta=dot(-lightDir,normalize(l_dir));
								float epsilon=l_inner-l_outer;
								float intensity=clamp((theta-l_outer)/epsilon,0.,1.);
								// combine results
								
								vec3 diffuse=l_colour*diff*m_diffuse;
								vec3 specular=l_colour*spec*m_specular;
								diffuse*=attenuation*intensity;
								specular*=attenuation*intensity;
								color+=(diffuse+specular)*m_colour;
							}
							break;
						}
					}
					color+=m_ambient*m_colour;
				}
			}
			else
			{
				color=m_colour;
				// remember that the default material colour is in the constructor of Material
			}
			frag_color=vec4(color,1.);
			// frag_color = vec4(vec3(lightBlock.lights[0].kQ * 500.0,lightBlock.lights[0].kQ * 500.0,lightBlock.lights[0].kQ * 500.0), 1.0);
			// frag_color = vec4(vec3(), 1.0);
		}
		